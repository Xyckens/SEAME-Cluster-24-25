<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JetPackJoyRide: libcamera::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JetPackJoyRide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="classlibcamera_1_1Object.html">Object</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibcamera_1_1Object-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">libcamera::Object Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base object to support automatic signal disconnection.  
 <a href="classlibcamera_1_1Object.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for libcamera::Object:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlibcamera_1_1Object.png" usemap="#libcamera::Object_map" alt=""/>
  <map id="libcamera::Object_map" name="libcamera::Object_map">
<area href="classCpuSetTester.html" alt="CpuSetTester" shape="rect" coords="181,56,352,80"/>
<area href="classEventHandler.html" alt="EventHandler" shape="rect" coords="181,112,352,136"/>
<area href="classIPAInterfaceTest.html" alt="IPAInterfaceTest" shape="rect" coords="181,168,352,192"/>
<area href="classInstrumentedObject.html" alt="InstrumentedObject" shape="rect" coords="181,224,352,248"/>
<area href="classInvokedObject.html" alt="InvokedObject" shape="rect" coords="181,280,352,304"/>
<area href="classMessageReceiver.html" alt="MessageReceiver" shape="rect" coords="181,336,352,360"/>
<area href="classRecursiveMessageReceiver.html" alt="RecursiveMessageReceiver" shape="rect" coords="181,392,352,416"/>
<area href="classSignalReceiver.html" alt="SignalReceiver" shape="rect" coords="181,448,352,472"/>
<area href="classSlotMulti.html" alt="SlotMulti" shape="rect" coords="181,504,352,528"/>
<area href="classSlotObject.html" alt="SlotObject" shape="rect" coords="181,560,352,584"/>
<area href="classTestObject.html" alt="TestObject" shape="rect" coords="181,616,352,640"/>
<area href="classTimeoutHandler.html" alt="TimeoutHandler" shape="rect" coords="181,672,352,696"/>
<area href="classTimeoutHandler.html" alt="TimeoutHandler" shape="rect" coords="181,728,352,752"/>
<area href="classlibcamera_1_1Camera.html" title="Camera device." alt="libcamera::Camera" shape="rect" coords="181,784,352,808"/>
<area href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system." alt="libcamera::CameraManager" shape="rect" coords="181,840,352,864"/>
<area href="classlibcamera_1_1DebayerCpu.html" title="Class for debayering on the CPU." alt="libcamera::DebayerCpu" shape="rect" coords="181,896,352,920"/>
<area href="classlibcamera_1_1EventNotifier.html" title="Notify of activity on a file descriptor." alt="libcamera::EventNotifier" shape="rect" coords="181,952,352,976"/>
<area href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices." alt="libcamera::PipelineHandler" shape="rect" coords="181,1008,352,1032"/>
<area href="classlibcamera_1_1Timer.html" title="Single-shot timer interface." alt="libcamera::Timer" shape="rect" coords="181,1064,352,1088"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0425e0a986630b5881558378fad91687" id="r_a0425e0a986630b5881558378fad91687"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a0425e0a986630b5881558378fad91687">Object</a> (<a class="el" href="classlibcamera_1_1Object.html">Object</a> *<a class="el" href="classlibcamera_1_1Object.html#a469143548519e7ac9525e5b2b45e983f">parent</a>=nullptr)</td></tr>
<tr class="memdesc:a0425e0a986630b5881558378fad91687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <br /></td></tr>
<tr class="separator:a0425e0a986630b5881558378fad91687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c17ff4161b166ae71e766d0649b97" id="r_ad52c17ff4161b166ae71e766d0649b97"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#ad52c17ff4161b166ae71e766d0649b97">~Object</a> ()</td></tr>
<tr class="memdesc:ad52c17ff4161b166ae71e766d0649b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <br /></td></tr>
<tr class="separator:ad52c17ff4161b166ae71e766d0649b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7432a52a2e69a29cfe8144929686d1e6" id="r_a7432a52a2e69a29cfe8144929686d1e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a7432a52a2e69a29cfe8144929686d1e6">deleteLater</a> ()</td></tr>
<tr class="memdesc:a7432a52a2e69a29cfe8144929686d1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule deletion of the instance in the thread it belongs to.  <br /></td></tr>
<tr class="separator:a7432a52a2e69a29cfe8144929686d1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ae92dfe5f3741c64ebdec61a2f5bef" id="r_af9ae92dfe5f3741c64ebdec61a2f5bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#af9ae92dfe5f3741c64ebdec61a2f5bef">postMessage</a> (std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1Message.html">Message</a> &gt; msg)</td></tr>
<tr class="memdesc:af9ae92dfe5f3741c64ebdec61a2f5bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a message to the object's thread.  <br /></td></tr>
<tr class="separator:af9ae92dfe5f3741c64ebdec61a2f5bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4ea2209e289e2aabb75c5718d5b4a7" id="r_a2a4ea2209e289e2aabb75c5718d5b4a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename... FuncArgs, typename... Args, std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classlibcamera_1_1Object.html">Object</a>, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a4ea2209e289e2aabb75c5718d5b4a7"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a2a4ea2209e289e2aabb75c5718d5b4a7">invokeMethod</a> (R(T::*func)(FuncArgs...), <a class="el" href="namespacelibcamera.html#ae2c8412791b9597d590a7d0b2c9e2919">ConnectionType</a> type, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2a4ea2209e289e2aabb75c5718d5b4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a method asynchronously on an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <br /></td></tr>
<tr class="separator:a2a4ea2209e289e2aabb75c5718d5b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca52b8790edc25af65d6fe937355577b" id="r_aca52b8790edc25af65d6fe937355577b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1Thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#aca52b8790edc25af65d6fe937355577b">thread</a> () const</td></tr>
<tr class="memdesc:aca52b8790edc25af65d6fe937355577b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread the object is bound to \context This function is \threadsafe.  <br /></td></tr>
<tr class="separator:aca52b8790edc25af65d6fe937355577b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8045a16ae8a093722466ca7129db6fc2" id="r_a8045a16ae8a093722466ca7129db6fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a8045a16ae8a093722466ca7129db6fc2">moveToThread</a> (<a class="el" href="classlibcamera_1_1Thread.html">Thread</a> *<a class="el" href="classlibcamera_1_1Object.html#aca52b8790edc25af65d6fe937355577b">thread</a>)</td></tr>
<tr class="memdesc:a8045a16ae8a093722466ca7129db6fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the object and all its children to a different thread.  <br /></td></tr>
<tr class="separator:a8045a16ae8a093722466ca7129db6fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469143548519e7ac9525e5b2b45e983f" id="r_a469143548519e7ac9525e5b2b45e983f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a469143548519e7ac9525e5b2b45e983f">parent</a> () const</td></tr>
<tr class="memdesc:a469143548519e7ac9525e5b2b45e983f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the object's parent.  <br /></td></tr>
<tr class="separator:a469143548519e7ac9525e5b2b45e983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5328cab1412743716aa2748eeded8e80" id="r_a5328cab1412743716aa2748eeded8e80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80">message</a> (<a class="el" href="classlibcamera_1_1Message.html">Message</a> *msg)</td></tr>
<tr class="memdesc:a5328cab1412743716aa2748eeded8e80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibcamera_1_1Message.html" title="A message that can be posted to a Thread.">Message</a> handler for the object.  <br /></td></tr>
<tr class="separator:a5328cab1412743716aa2748eeded8e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81f2a2524dbe12daed49597cf66a57" id="r_a6e81f2a2524dbe12daed49597cf66a57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a6e81f2a2524dbe12daed49597cf66a57">assertThreadBound</a> (const char *<a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80">message</a>)</td></tr>
<tr class="memdesc:a6e81f2a2524dbe12daed49597cf66a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the caller complies with thread-bound constraints.  <br /></td></tr>
<tr class="separator:a6e81f2a2524dbe12daed49597cf66a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a79e6178547d39d470bb1e71f933bd609" id="r_a79e6178547d39d470bb1e71f933bd609"><td class="memItemLeft" align="right" valign="top"><a id="a79e6178547d39d470bb1e71f933bd609" name="a79e6178547d39d470bb1e71f933bd609"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SignalBase</b></td></tr>
<tr class="separator:a79e6178547d39d470bb1e71f933bd609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc148eaddd341d7ae4d07c9e9e33bfd" id="r_adbc148eaddd341d7ae4d07c9e9e33bfd"><td class="memItemLeft" align="right" valign="top"><a id="adbc148eaddd341d7ae4d07c9e9e33bfd" name="adbc148eaddd341d7ae4d07c9e9e33bfd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Thread</b></td></tr>
<tr class="separator:adbc148eaddd341d7ae4d07c9e9e33bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base object to support automatic signal disconnection. </p>
<p>The <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> class simplifies signal/slot handling for classes implementing slots. By inheriting from <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a>, an object is automatically disconnected from all connected signals when it gets destroyed.</p>
<p><a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instances are bound to the thread of their parent, or the thread in which they're created when they have no parent. When a message is posted to an object, its handler will run in the object's thread. This allows implementing easy message passing between threads by inheriting from the <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> class.</p>
<p>Deleting an object from a thread other than the one the object is bound to is unsafe, unless the caller ensures that the object's thread is stopped and no parent or child of the object gets deleted concurrently. See <a class="el" href="classlibcamera_1_1Object.html#ad52c17ff4161b166ae71e766d0649b97" title="Destroy an Object instance.">Object::~Object()</a> for more information.</p>
<p><a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> slots connected to signals will also run in the context of the object's thread, regardless of whether the signal is emitted in the same or in another thread.</p>
<p>Objects can be connected to multiple signals, but they can only be connected to each signal once. Attempting to create multiple concurrent connections between the same signal and the same <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> (to either the same or differents slots of the object) will cause an assertion failure. While it would be possible to allow the implementation to let objects connect to the same signal multiple times, there are no expected use cases for this in libcamera and this behaviour is restricted to favour defensive programming.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1Message.html" title="A message that can be posted to a Thread.">Message</a>, <a class="el" href="classlibcamera_1_1Signal.html" title="Generic signal and slot communication mechanism.">Signal</a>, <a class="el" href="classlibcamera_1_1Thread.html" title="A thread of execution.">Thread</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0425e0a986630b5881558378fad91687" name="a0425e0a986630b5881558378fad91687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0425e0a986630b5881558378fad91687">&#9670;&#160;</a></span>Object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::Object::Object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Object.html">Object</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The object parent</td></tr>
  </table>
  </dd>
</dl>
<p>The new <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance is bound to the thread of its <em>parent</em>, or to the current thread if the <em>parent</em> is nullptr. </p>

</div>
</div>
<a id="ad52c17ff4161b166ae71e766d0649b97" name="ad52c17ff4161b166ae71e766d0649b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52c17ff4161b166ae71e766d0649b97">&#9670;&#160;</a></span>~Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::Object::~Object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance. </p>
<p>Deleting an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> automatically disconnects all signals from the <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a>'s slots. All the <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a>'s children are made orphan, but stay bound to their current thread.</p>
<p><a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instances shall be destroyed from the thread they are bound to, otherwise undefined behaviour may occur. If deletion of an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> needs to be scheduled from a different thread, <a class="el" href="classlibcamera_1_1Object.html#a7432a52a2e69a29cfe8144929686d1e6" title="Schedule deletion of the instance in the thread it belongs to.">deleteLater()</a> shall be used.</p>
<p>As an exception to this rule, <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instances may be deleted from a different thread if the thread the instance is bound to is stopped through the whole duration of the object's destruction, <em>and</em> the parent and children of the object do not get deleted concurrently. The caller is responsible for fulfilling those requirements.</p>
<p>In all cases <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instances shall be deleted before the <a class="el" href="classlibcamera_1_1Thread.html" title="A thread of execution.">Thread</a> they are bound to. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e81f2a2524dbe12daed49597cf66a57" name="a6e81f2a2524dbe12daed49597cf66a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e81f2a2524dbe12daed49597cf66a57">&#9670;&#160;</a></span>assertThreadBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::Object::assertThreadBound </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the caller complies with thread-bound constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message to be printed on error</td></tr>
  </table>
  </dd>
</dl>
<p>This function verifies the calling constraints required by the \threadbound definition. It shall be called at the beginning of member functions of an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> subclass that are explicitly marked as thread-bound in their documentation.</p>
<p>If the thread-bound constraints are not met, the function prints <em>message</em> as an error message. For debug builds, it additionally causes an assertion error.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Verify the thread-bound requirements for functions marked as thread-bound at the class level.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the call is thread-bound compliant, false otherwise </dd></dl>

</div>
</div>
<a id="a7432a52a2e69a29cfe8144929686d1e6" name="a7432a52a2e69a29cfe8144929686d1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7432a52a2e69a29cfe8144929686d1e6">&#9670;&#160;</a></span>deleteLater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::Object::deleteLater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule deletion of the instance in the thread it belongs to. </p>
<p>This function schedules deletion of the <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> when control returns to the event loop that the object belongs to. This ensures the object is destroyed from the right context, as required by the libcamera threading model.</p>
<p>If this function is called before the thread's event loop is started or after it has stopped, the object will be deleted when the event loop (re)starts. If this never occurs, the object will be leaked.</p>
<p>Deferred deletion can be used to control the destruction context with shared pointers. An object managed with shared pointers is deleted when the last reference is destroyed, which makes difficult to ensure through software design which context the deletion will take place in. With a custom deleter for the shared pointer using <a class="el" href="classlibcamera_1_1Object.html#a7432a52a2e69a29cfe8144929686d1e6" title="Schedule deletion of the instance in the thread it belongs to.">deleteLater()</a>, the deletion can be guaranteed to happen in the thread the object is bound to.</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;MyObject&gt; createObject()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>Deleter : std::default_delete&lt;MyObject&gt; {</div>
<div class="line">            <span class="keywordtype">void</span> operator()(MyObject *obj)</div>
<div class="line">            {</div>
<div class="line">                    obj-&gt;deleteLater();</div>
<div class="line">            }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyObject *obj = <span class="keyword">new</span> MyObject();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::shared_ptr&lt;MyObject&gt;(obj, Deleter());</div>
<div class="line">}</div>
</div><!-- fragment --><p>\context This function is \threadsafe. </p>

</div>
</div>
<a id="a2a4ea2209e289e2aabb75c5718d5b4a7" name="a2a4ea2209e289e2aabb75c5718d5b4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4ea2209e289e2aabb75c5718d5b4a7">&#9670;&#160;</a></span>invokeMethod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R , typename... FuncArgs, typename... Args, std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classlibcamera_1_1Object.html">Object</a>, T &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R libcamera::Object::invokeMethod </td>
          <td>(</td>
          <td class="paramtype">R(T::*)(FuncArgs...)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcamera.html#ae2c8412791b9597d590a7d0b2c9e2919">ConnectionType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a method asynchronously on an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The object method to invoke </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Connection type for method invocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The method arguments</td></tr>
  </table>
  </dd>
</dl>
<p>This function invokes the member method <em>func</em> with arguments <em>args</em>, based on the connection <em>type</em>. Depending on the type, the method will be called synchronously in the same thread or asynchronously in the object's thread.</p>
<p>Arguments <em>args</em> passed by value or reference are copied, while pointers are passed untouched. The caller shall ensure that any pointer argument remains valid until the method is invoked.</p>
<p>Due to the asynchronous nature of threads, functions invoked asynchronously with the ConnectionTypeQueued type are not guaranteed to be called before the thread is stopped. See <a class="el" href="classlibcamera_1_1Thread.html#thread-stop">Stopping Threads</a> for additional information.</p>
<p>\context This function is \threadsafe.</p>
<dl class="section return"><dt>Returns</dt><dd>For connection types ConnectionTypeDirect and ConnectionTypeBlocking, return the return value of the invoked method. For connection type ConnectionTypeQueued, return a default-constructed R value. </dd></dl>

</div>
</div>
<a id="a5328cab1412743716aa2748eeded8e80" name="a5328cab1412743716aa2748eeded8e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5328cab1412743716aa2748eeded8e80">&#9670;&#160;</a></span>message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::Object::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Message.html">Message</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classlibcamera_1_1Message.html" title="A message that can be posted to a Thread.">Message</a> handler for the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The message</td></tr>
  </table>
  </dd>
</dl>
<p>This virtual function receives messages for the object. It is called in the context of the object's thread, and can be overridden to process custom messages. The parent <a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80" title="Message handler for the object.">Object::message()</a> function shall be called for any message not handled by the override function.</p>
<p>The message <em>msg</em> is valid only for the duration of the call, no reference to it shall be kept after this function returns. </p>

<p>Reimplemented in <a class="el" href="classMessageReceiver.html#a66415c0b2ad9cbe57f6fac957be269d2">MessageReceiver</a>, <a class="el" href="classRecursiveMessageReceiver.html#a88eb29dd3084571fb89068ea533dd4d2">RecursiveMessageReceiver</a>, <a class="el" href="classlibcamera_1_1EventNotifier.html#a83550c524a9bcc0ea582e876ca43c04d">libcamera::EventNotifier</a>, <a class="el" href="classlibcamera_1_1Timer.html#a3ed22e72f2b3001a17e8aedcc6374c0c">libcamera::Timer</a>, and <a class="el" href="classInstrumentedObject.html#a22aab2161d4ba860b4cae0b651586851">InstrumentedObject</a>.</p>

</div>
</div>
<a id="a8045a16ae8a093722466ca7129db6fc2" name="a8045a16ae8a093722466ca7129db6fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8045a16ae8a093722466ca7129db6fc2">&#9670;&#160;</a></span>moveToThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::Object::moveToThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the object and all its children to a different thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The target thread</td></tr>
  </table>
  </dd>
</dl>
<p>This function moves the object and all its children from the current thread to the new <em>thread</em>.</p>
<p>Before the object is moved, a <a class="el" href="classlibcamera_1_1Message.html#a7ae15d74f028344ba827ea8ba4d77fa5a5f1a6bad8554e6afcc20a1713f08cbee" title="Object is being moved to a different thread.">Message::ThreadMoveMessage</a> message is sent to it. The <a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80" title="Message handler for the object.">message()</a> function can be reimplement in derived classes to be notified of the upcoming thread move and perform any required processing.</p>
<p>Moving an object that has a parent is not allowed, and causes undefined behaviour.</p>
<p>\context This function is \threadbound. </p>

</div>
</div>
<a id="a469143548519e7ac9525e5b2b45e983f" name="a469143548519e7ac9525e5b2b45e983f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469143548519e7ac9525e5b2b45e983f">&#9670;&#160;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::Object::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the object's parent. </p>
<dl class="section return"><dt>Returns</dt><dd>The object's parent </dd></dl>

</div>
</div>
<a id="af9ae92dfe5f3741c64ebdec61a2f5bef" name="af9ae92dfe5f3741c64ebdec61a2f5bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ae92dfe5f3741c64ebdec61a2f5bef">&#9670;&#160;</a></span>postMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::Object::postMessage </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1Message.html">Message</a> &gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a message to the object's thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The message</td></tr>
  </table>
  </dd>
</dl>
<p>This function posts the message <em>msg</em> to the message queue of the object's thread, to be delivered to the object through the <a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80" title="Message handler for the object.">message()</a> function in the context of its thread. <a class="el" href="classlibcamera_1_1Message.html" title="A message that can be posted to a Thread.">Message</a> ownership is passed to the thread, and the message will be deleted after being delivered.</p>
<p>Messages are delivered through the thread's event loop. If the thread is not running its event loop the message will not be delivered until the event loop gets started.</p>
<p>Due to their asynchronous nature, threads do not provide any guarantee that all posted messages are delivered before the thread is stopped. See <a class="el" href="classlibcamera_1_1Thread.html#thread-stop">Stopping Threads</a> for additional information.</p>
<p>\context This function is \threadsafe. </p>

</div>
</div>
<a id="aca52b8790edc25af65d6fe937355577b" name="aca52b8790edc25af65d6fe937355577b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca52b8790edc25af65d6fe937355577b">&#9670;&#160;</a></span>thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::Object::thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the thread the object is bound to \context This function is \threadsafe. </p>
<dl class="section return"><dt>Returns</dt><dd>The thread the object is bound to </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/peripherals/camera/libcamera/include/libcamera/base/<a class="el" href="object_8h_source.html">object.h</a></li>
<li>src/peripherals/camera/libcamera/src/libcamera/base/<b>object.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
