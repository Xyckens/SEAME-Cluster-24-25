<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JetPackJoyRide: libcamera::ByteStreamBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JetPackJoyRide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibcamera_1_1ByteStreamBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">libcamera::ByteStreamBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrap a memory buffer and provide sequential data read and write.  
 <a href="classlibcamera_1_1ByteStreamBuffer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab08c12dd64a532b30e6606688a96d70" id="r_aab08c12dd64a532b30e6606688a96d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#aab08c12dd64a532b30e6606688a96d70">ByteStreamBuffer</a> (const uint8_t *<a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a61bfdddc677f7c3bc589f956f269018c">base</a>, size_t <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab6b3af2aaaec289b4502e7cee4a64183">size</a>)</td></tr>
<tr class="memdesc:aab08c12dd64a532b30e6606688a96d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a read <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the memory area <em>base</em> of <em>size</em>.  <br /></td></tr>
<tr class="separator:aab08c12dd64a532b30e6606688a96d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa1e97f387a892b20ab201b74fe82c0" id="r_abfa1e97f387a892b20ab201b74fe82c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#abfa1e97f387a892b20ab201b74fe82c0">ByteStreamBuffer</a> (uint8_t *<a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a61bfdddc677f7c3bc589f956f269018c">base</a>, size_t <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab6b3af2aaaec289b4502e7cee4a64183">size</a>)</td></tr>
<tr class="memdesc:abfa1e97f387a892b20ab201b74fe82c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a write <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the memory area <em>base</em> of <em>size</em>.  <br /></td></tr>
<tr class="separator:abfa1e97f387a892b20ab201b74fe82c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b0355a9b76b2cc9641ca228839000c" id="r_a15b0355a9b76b2cc9641ca228839000c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a15b0355a9b76b2cc9641ca228839000c">ByteStreamBuffer</a> (<a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a15b0355a9b76b2cc9641ca228839000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the contents of <em>other</em> using move semantics.  <br /></td></tr>
<tr class="separator:a15b0355a9b76b2cc9641ca228839000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311fc7a5d897e86b50f15751c31bf006" id="r_a311fc7a5d897e86b50f15751c31bf006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a311fc7a5d897e86b50f15751c31bf006">operator=</a> (<a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a311fc7a5d897e86b50f15751c31bf006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents of the buffer with those of <em>other</em> using move semantics.  <br /></td></tr>
<tr class="separator:a311fc7a5d897e86b50f15751c31bf006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bfdddc677f7c3bc589f956f269018c" id="r_a61bfdddc677f7c3bc589f956f269018c"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a61bfdddc677f7c3bc589f956f269018c">base</a> () const</td></tr>
<tr class="memdesc:a61bfdddc677f7c3bc589f956f269018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the start location of the managed memory buffer.  <br /></td></tr>
<tr class="separator:a61bfdddc677f7c3bc589f956f269018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dd3793fe90e5d525087275c83efe30" id="r_a84dd3793fe90e5d525087275c83efe30"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a84dd3793fe90e5d525087275c83efe30">offset</a> () const</td></tr>
<tr class="memdesc:a84dd3793fe90e5d525087275c83efe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the offset of the current access location from the base.  <br /></td></tr>
<tr class="separator:a84dd3793fe90e5d525087275c83efe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b3af2aaaec289b4502e7cee4a64183" id="r_ab6b3af2aaaec289b4502e7cee4a64183"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab6b3af2aaaec289b4502e7cee4a64183">size</a> () const</td></tr>
<tr class="memdesc:ab6b3af2aaaec289b4502e7cee4a64183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of the managed memory buffer.  <br /></td></tr>
<tr class="separator:ab6b3af2aaaec289b4502e7cee4a64183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb29445e9ea98ad3df00ac60e3f58786" id="r_acb29445e9ea98ad3df00ac60e3f58786"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#acb29445e9ea98ad3df00ac60e3f58786">overflow</a> () const</td></tr>
<tr class="memdesc:acb29445e9ea98ad3df00ac60e3f58786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer has overflown.  <br /></td></tr>
<tr class="separator:acb29445e9ea98ad3df00ac60e3f58786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be0172bbc8c87b267f4ff162166743d" id="r_a1be0172bbc8c87b267f4ff162166743d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a1be0172bbc8c87b267f4ff162166743d">carveOut</a> (size_t <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab6b3af2aaaec289b4502e7cee4a64183">size</a>)</td></tr>
<tr class="memdesc:a1be0172bbc8c87b267f4ff162166743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carve out an area of <em>size</em> bytes into a new <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a>.  <br /></td></tr>
<tr class="separator:a1be0172bbc8c87b267f4ff162166743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8a084b45dfd4f29092aab83d4961cd" id="r_a8a8a084b45dfd4f29092aab83d4961cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a8a8a084b45dfd4f29092aab83d4961cd">skip</a> (size_t <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab6b3af2aaaec289b4502e7cee4a64183">size</a>)</td></tr>
<tr class="memdesc:a8a8a084b45dfd4f29092aab83d4961cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip <em>size</em> bytes from the buffer.  <br /></td></tr>
<tr class="separator:a8a8a084b45dfd4f29092aab83d4961cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904b7ed94da3c8d266863a1ed2cf995" id="r_ad904b7ed94da3c8d266863a1ed2cf995"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad904b7ed94da3c8d266863a1ed2cf995"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ad904b7ed94da3c8d266863a1ed2cf995">read</a> (T *t)</td></tr>
<tr class="memdesc:ad904b7ed94da3c8d266863a1ed2cf995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the managed memory buffer into <em>t</em>.  <br /></td></tr>
<tr class="separator:ad904b7ed94da3c8d266863a1ed2cf995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a614c18384f105e295724f9aef2a1ec" id="r_a8a614c18384f105e295724f9aef2a1ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a614c18384f105e295724f9aef2a1ec"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a8a614c18384f105e295724f9aef2a1ec">read</a> (const <a class="el" href="classlibcamera_1_1Span.html">Span</a>&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:a8a614c18384f105e295724f9aef2a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the managed memory buffer into <a class="el" href="classlibcamera_1_1Span.html">Span</a> <em>data</em>.  <br /></td></tr>
<tr class="separator:a8a614c18384f105e295724f9aef2a1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5128ab4e3c75aa968dee6dd5ed0f2d94" id="r_a5128ab4e3c75aa968dee6dd5ed0f2d94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5128ab4e3c75aa968dee6dd5ed0f2d94"><td class="memTemplItemLeft" align="right" valign="top">const std::remove_reference_t&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a5128ab4e3c75aa968dee6dd5ed0f2d94">read</a> (size_t count=1)</td></tr>
<tr class="memdesc:a5128ab4e3c75aa968dee6dd5ed0f2d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the managed memory buffer without performing a copy.  <br /></td></tr>
<tr class="separator:a5128ab4e3c75aa968dee6dd5ed0f2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0b98c87ec6feb3785eb576f684e40c" id="r_acc0b98c87ec6feb3785eb576f684e40c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc0b98c87ec6feb3785eb576f684e40c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#acc0b98c87ec6feb3785eb576f684e40c">write</a> (const T *t)</td></tr>
<tr class="memdesc:acc0b98c87ec6feb3785eb576f684e40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <em>t</em> to the managed memory buffer.  <br /></td></tr>
<tr class="separator:acc0b98c87ec6feb3785eb576f684e40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ce758fb1ebca947457e38c450dc20" id="r_ab79ce758fb1ebca947457e38c450dc20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab79ce758fb1ebca947457e38c450dc20"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ab79ce758fb1ebca947457e38c450dc20">write</a> (const <a class="el" href="classlibcamera_1_1Span.html">Span</a>&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:ab79ce758fb1ebca947457e38c450dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <em>data</em> to the managed memory buffer.  <br /></td></tr>
<tr class="separator:ab79ce758fb1ebca947457e38c450dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrap a memory buffer and provide sequential data read and write. </p>
<p>The <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> class wraps a memory buffer and exposes sequential read and write operation with integrated boundary checks. Access beyond the end of the buffer are blocked and logged, allowing error checks to take place at the of of access operations instead of at each access. This simplifies serialization and deserialization of data.</p>
<p>A byte stream buffer is created with a base memory pointer and a size. If the memory pointer is const, the buffer operates in read-only mode, and write operations are denied. Otherwise the buffer operates in write-only mode, and read operations are denied.</p>
<p>Once a buffer is created, data is read or written with <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#ad904b7ed94da3c8d266863a1ed2cf995" title="Read data from the managed memory buffer into t.">read()</a> and <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#acc0b98c87ec6feb3785eb576f684e40c" title="Write t to the managed memory buffer.">write()</a> respectively. Access is strictly sequential, the buffer keeps track of the current access location and advances it automatically. Reading or writing the same location multiple times is thus not possible. Bytes may also be skipped with the <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a8a8a084b45dfd4f29092aab83d4961cd" title="Skip size bytes from the buffer.">skip()</a> function.</p>
<p>The <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> also supports carving out pieces of memory into other <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> instances. Like a read or write operation, a <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#a1be0172bbc8c87b267f4ff162166743d" title="Carve out an area of size bytes into a new ByteStreamBuffer.">carveOut()</a> advances the internal access location, but allows the carved out memory to be accessed at a later time.</p>
<p>All accesses beyond the end of the buffer (read, write, skip or carve out) are blocked. The first of such accesses causes a message to be logged, and the buffer being marked as having overflown. If the buffer has been carved out from a parent buffer, the parent buffer is also marked as having overflown. Any later access on an overflown buffer is blocked. The buffer overflow status can be checked with the <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html#acb29445e9ea98ad3df00ac60e3f58786" title="Check if the buffer has overflown.">overflow()</a> function. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab08c12dd64a532b30e6606688a96d70" name="aab08c12dd64a532b30e6606688a96d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab08c12dd64a532b30e6606688a96d70">&#9670;&#160;</a></span>ByteStreamBuffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::ByteStreamBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a read <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the memory area <em>base</em> of <em>size</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The address of the memory area to wrap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the memory area to wrap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfa1e97f387a892b20ab201b74fe82c0" name="abfa1e97f387a892b20ab201b74fe82c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa1e97f387a892b20ab201b74fe82c0">&#9670;&#160;</a></span>ByteStreamBuffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::ByteStreamBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a write <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the memory area <em>base</em> of <em>size</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The address of the memory area to wrap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the memory area to wrap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15b0355a9b76b2cc9641ca228839000c" name="a15b0355a9b76b2cc9641ca228839000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b0355a9b76b2cc9641ca228839000c">&#9670;&#160;</a></span>ByteStreamBuffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::ByteStreamBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> from the contents of <em>other</em> using move semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other buffer</td></tr>
  </table>
  </dd>
</dl>
<p>After the move construction the <em>other</em> buffer is invalidated. Any attempt to access its contents will be considered as an overflow. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61bfdddc677f7c3bc589f956f269018c" name="a61bfdddc677f7c3bc589f956f269018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bfdddc677f7c3bc589f956f269018c">&#9670;&#160;</a></span>base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the start location of the managed memory buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the managed memory buffer </dd></dl>

</div>
</div>
<a id="a1be0172bbc8c87b267f4ff162166743d" name="a1be0172bbc8c87b267f4ff162166743d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be0172bbc8c87b267f4ff162166743d">&#9670;&#160;</a></span>carveOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> libcamera::ByteStreamBuffer::carveOut </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carve out an area of <em>size</em> bytes into a new <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the newly created memory buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This function carves out an area of <em>size</em> bytes from the buffer into a new <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a>, and returns the new buffer. It operates identically to a read or write access from the point of view of the current buffer, but allows the new buffer to be read or written at a later time after other read or write accesses on the current buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created <a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> of <em>size</em> </dd></dl>

</div>
</div>
<a id="a84dd3793fe90e5d525087275c83efe30" name="a84dd3793fe90e5d525087275c83efe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dd3793fe90e5d525087275c83efe30">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the offset of the current access location from the base. </p>
<dl class="section return"><dt>Returns</dt><dd>The offset in bytes </dd></dl>

</div>
</div>
<a id="a311fc7a5d897e86b50f15751c31bf006" name="a311fc7a5d897e86b50f15751c31bf006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311fc7a5d897e86b50f15751c31bf006">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp; libcamera::ByteStreamBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1ByteStreamBuffer.html">ByteStreamBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents of the buffer with those of <em>other</em> using move semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other buffer</td></tr>
  </table>
  </dd>
</dl>
<p>After the assignment the <em>other</em> buffer is invalidated. Any attempt to access its contents will be considered as an overflow. </p>

</div>
</div>
<a id="acb29445e9ea98ad3df00ac60e3f58786" name="acb29445e9ea98ad3df00ac60e3f58786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb29445e9ea98ad3df00ac60e3f58786">&#9670;&#160;</a></span>overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::overflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer has overflown. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer has overflow, false otherwise </dd></dl>

</div>
</div>
<a id="a8a614c18384f105e295724f9aef2a1ec" name="a8a614c18384f105e295724f9aef2a1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a614c18384f105e295724f9aef2a1ec">&#9670;&#160;</a></span>read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; int libcamera::ByteStreamBuffer::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Span.html">Span</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the managed memory buffer into <a class="el" href="classlibcamera_1_1Span.html">Span</a> <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><a class="el" href="classlibcamera_1_1Span.html">Span</a> representing the destination memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EACCES</td><td>attempting to read from a write buffer </td></tr>
    <tr><td class="paramname">-ENOSPC</td><td>no more space is available in the managed memory buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5128ab4e3c75aa968dee6dd5ed0f2d94" name="a5128ab4e3c75aa968dee6dd5ed0f2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5128ab4e3c75aa968dee6dd5ed0f2d94">&#9670;&#160;</a></span>read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; const T * libcamera::ByteStreamBuffer::read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the managed memory buffer without performing a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of data items to read</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads <em>count</em> elements of type <em>T</em> from the buffer. Unlike the other read variants, it doesn't copy the data but returns a pointer to the first element. If data can't be read for any reason (usually due to reading more data than available), the function returns nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data on success, or nullptr otherwise </dd></dl>

</div>
</div>
<a id="ad904b7ed94da3c8d266863a1ed2cf995" name="ad904b7ed94da3c8d266863a1ed2cf995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad904b7ed94da3c8d266863a1ed2cf995">&#9670;&#160;</a></span>read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; int libcamera::ByteStreamBuffer::read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the managed memory buffer into <em>t</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Pointer to the memory containing the read data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EACCES</td><td>attempting to read from a write buffer </td></tr>
    <tr><td class="paramname">-ENOSPC</td><td>no more space is available in the managed memory buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6b3af2aaaec289b4502e7cee4a64183" name="ab6b3af2aaaec289b4502e7cee4a64183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b3af2aaaec289b4502e7cee4a64183">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::ByteStreamBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the size of the managed memory buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of managed memory buffer </dd></dl>

</div>
</div>
<a id="a8a8a084b45dfd4f29092aab83d4961cd" name="a8a8a084b45dfd4f29092aab83d4961cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8a084b45dfd4f29092aab83d4961cd">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libcamera::ByteStreamBuffer::skip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip <em>size</em> bytes from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to skip</td></tr>
  </table>
  </dd>
</dl>
<p>This function skips the next <em>size</em> bytes from the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSPC</td><td>no more space is available in the managed memory buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab79ce758fb1ebca947457e38c450dc20" name="ab79ce758fb1ebca947457e38c450dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ce758fb1ebca947457e38c450dc20">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; int libcamera::ByteStreamBuffer::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Span.html">Span</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write <em>data</em> to the managed memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EACCES</td><td>attempting to write to a read buffer </td></tr>
    <tr><td class="paramname">-ENOSPC</td><td>no more space is available in the managed memory buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc0b98c87ec6feb3785eb576f684e40c" name="acc0b98c87ec6feb3785eb576f684e40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0b98c87ec6feb3785eb576f684e40c">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; int libcamera::ByteStreamBuffer::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write <em>t</em> to the managed memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data to write to memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EACCES</td><td>attempting to write to a read buffer </td></tr>
    <tr><td class="paramname">-ENOSPC</td><td>no more space is available in the managed memory buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/peripherals/camera/libcamera/include/libcamera/internal/<a class="el" href="byte__stream__buffer_8h_source.html">byte_stream_buffer.h</a></li>
<li>src/peripherals/camera/libcamera/src/libcamera/<b>byte_stream_buffer.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
