<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JetPackJoyRide: libcamera::PixelFormatInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JetPackJoyRide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classlibcamera_1_1PixelFormatInfo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">libcamera::PixelFormatInfo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Information about pixel formats.  
 <a href="classlibcamera_1_1PixelFormatInfo.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibcamera_1_1PixelFormatInfo_1_1Plane.html">Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a single plane of a pixel format.  <a href="structlibcamera_1_1PixelFormatInfo_1_1Plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a021bf0e82baec37b1523baa3322dc23c" id="r_a021bf0e82baec37b1523baa3322dc23c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23c">ColourEncoding</a> { <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23ca325a4a7e84e64027e36ce0c680f8d018">ColourEncodingRGB</a>
, <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23caa7f76b3873550b4beeacfd5d8491d910">ColourEncodingYUV</a>
, <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23cac31c601b597d4cd2f1ff016875d8e564">ColourEncodingRAW</a>
 }</td></tr>
<tr class="memdesc:a021bf0e82baec37b1523baa3322dc23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The colour encoding type.  <a href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23c">More...</a><br /></td></tr>
<tr class="separator:a021bf0e82baec37b1523baa3322dc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb11cb37fde348f29e723531b30344ac" id="r_acb11cb37fde348f29e723531b30344ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#acb11cb37fde348f29e723531b30344ac">isValid</a> () const</td></tr>
<tr class="memdesc:acb11cb37fde348f29e723531b30344ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the pixel format info is valid.  <br /></td></tr>
<tr class="separator:acb11cb37fde348f29e723531b30344ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a284dd919fd4aba5b18138d6eea02a" id="r_a37a284dd919fd4aba5b18138d6eea02a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a37a284dd919fd4aba5b18138d6eea02a">stride</a> (unsigned int width, unsigned int plane, unsigned int align=1) const</td></tr>
<tr class="memdesc:a37a284dd919fd4aba5b18138d6eea02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stride.  <br /></td></tr>
<tr class="separator:a37a284dd919fd4aba5b18138d6eea02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e125f99540866dac124ca50303f4f0" id="r_ac7e125f99540866dac124ca50303f4f0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#ac7e125f99540866dac124ca50303f4f0">planeSize</a> (const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;size, unsigned int plane, unsigned int align=1) const</td></tr>
<tr class="memdesc:ac7e125f99540866dac124ca50303f4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes necessary to store a plane of a frame.  <br /></td></tr>
<tr class="separator:ac7e125f99540866dac124ca50303f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce305a0a0536f2b2dfdaa99375fa7d1" id="r_acce305a0a0536f2b2dfdaa99375fa7d1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#acce305a0a0536f2b2dfdaa99375fa7d1">planeSize</a> (unsigned int height, unsigned int plane, unsigned int <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a37a284dd919fd4aba5b18138d6eea02a">stride</a>) const</td></tr>
<tr class="memdesc:acce305a0a0536f2b2dfdaa99375fa7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes necessary to store a plane of a frame.  <br /></td></tr>
<tr class="separator:acce305a0a0536f2b2dfdaa99375fa7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98fc36a8238e5fbb426089dddef273d" id="r_aa98fc36a8238e5fbb426089dddef273d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#aa98fc36a8238e5fbb426089dddef273d">frameSize</a> (const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;size, unsigned int align=1) const</td></tr>
<tr class="memdesc:aa98fc36a8238e5fbb426089dddef273d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes necessary to store a frame.  <br /></td></tr>
<tr class="separator:aa98fc36a8238e5fbb426089dddef273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06399e845afd406ce55cc6f1428c0742" id="r_a06399e845afd406ce55cc6f1428c0742"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a06399e845afd406ce55cc6f1428c0742">frameSize</a> (const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;size, const std::array&lt; unsigned int, 3 &gt; &amp;strides) const</td></tr>
<tr class="memdesc:a06399e845afd406ce55cc6f1428c0742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes necessary to store a frame.  <br /></td></tr>
<tr class="separator:a06399e845afd406ce55cc6f1428c0742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cca8a1c4b7bfd7ed8564812f6cdc49" id="r_a41cca8a1c4b7bfd7ed8564812f6cdc49"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a41cca8a1c4b7bfd7ed8564812f6cdc49">numPlanes</a> () const</td></tr>
<tr class="memdesc:a41cca8a1c4b7bfd7ed8564812f6cdc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of planes represented by the format.  <br /></td></tr>
<tr class="separator:a41cca8a1c4b7bfd7ed8564812f6cdc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab6778b5e339f41911b5fd08c3cb66531" id="r_ab6778b5e339f41911b5fd08c3cb66531"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#ab6778b5e339f41911b5fd08c3cb66531">info</a> (const <a class="el" href="classlibcamera_1_1PixelFormat.html">PixelFormat</a> &amp;<a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a26a938c3d1967e062fc20ec8df9c54b3">format</a>)</td></tr>
<tr class="memdesc:ab6778b5e339f41911b5fd08c3cb66531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a pixel format.  <br /></td></tr>
<tr class="separator:ab6778b5e339f41911b5fd08c3cb66531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce68ff4d70d12d94769735f8dd304f" id="r_ab5ce68ff4d70d12d94769735f8dd304f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#ab5ce68ff4d70d12d94769735f8dd304f">info</a> (const <a class="el" href="classlibcamera_1_1V4L2PixelFormat.html">V4L2PixelFormat</a> &amp;<a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a26a938c3d1967e062fc20ec8df9c54b3">format</a>)</td></tr>
<tr class="memdesc:ab5ce68ff4d70d12d94769735f8dd304f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a V4L2 pixel format.  <br /></td></tr>
<tr class="separator:ab5ce68ff4d70d12d94769735f8dd304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691e354c2bc55a433ed04d211c5f2b27" id="r_a691e354c2bc55a433ed04d211c5f2b27"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a691e354c2bc55a433ed04d211c5f2b27">info</a> (const std::string &amp;<a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a1aeacb31949df565216bb98d665125dd">name</a>)</td></tr>
<tr class="memdesc:a691e354c2bc55a433ed04d211c5f2b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a pixel format.  <br /></td></tr>
<tr class="separator:a691e354c2bc55a433ed04d211c5f2b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1aeacb31949df565216bb98d665125dd" id="r_a1aeacb31949df565216bb98d665125dd"><td class="memItemLeft" align="right" valign="top"><a id="a1aeacb31949df565216bb98d665125dd" name="a1aeacb31949df565216bb98d665125dd"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="memdesc:a1aeacb31949df565216bb98d665125dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format name as a human-readable string, used as the text representation of the <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a>. <br /></td></tr>
<tr class="separator:a1aeacb31949df565216bb98d665125dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a938c3d1967e062fc20ec8df9c54b3" id="r_a26a938c3d1967e062fc20ec8df9c54b3"><td class="memItemLeft" align="right" valign="top"><a id="a26a938c3d1967e062fc20ec8df9c54b3" name="a26a938c3d1967e062fc20ec8df9c54b3"></a>
<a class="el" href="classlibcamera_1_1PixelFormat.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>format</b></td></tr>
<tr class="memdesc:a26a938c3d1967e062fc20ec8df9c54b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a> described by this instance. <br /></td></tr>
<tr class="separator:a26a938c3d1967e062fc20ec8df9c54b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e6efba30a28758cb7553125b81580" id="r_a417e6efba30a28758cb7553125b81580"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibcamera_1_1V4L2PixelFormat.html">V4L2PixelFormat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a417e6efba30a28758cb7553125b81580">v4l2Formats</a></td></tr>
<tr class="memdesc:a417e6efba30a28758cb7553125b81580"><td class="mdescLeft">&#160;</td><td class="mdescRight">The V4L2 pixel formats corresponding to the <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a>.  <br /></td></tr>
<tr class="separator:a417e6efba30a28758cb7553125b81580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66facd7e91d5db482c0e7e49e8d81bd" id="r_af66facd7e91d5db482c0e7e49e8d81bd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#af66facd7e91d5db482c0e7e49e8d81bd">bitsPerPixel</a></td></tr>
<tr class="memdesc:af66facd7e91d5db482c0e7e49e8d81bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The average number of bits per pixel.  <br /></td></tr>
<tr class="separator:af66facd7e91d5db482c0e7e49e8d81bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876401366f11a4c02e6b5e1e3669219" id="r_a4876401366f11a4c02e6b5e1e3669219"><td class="memItemLeft" align="right" valign="top"><a id="a4876401366f11a4c02e6b5e1e3669219" name="a4876401366f11a4c02e6b5e1e3669219"></a>
enum <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23c">ColourEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><b>colourEncoding</b></td></tr>
<tr class="memdesc:a4876401366f11a4c02e6b5e1e3669219"><td class="mdescLeft">&#160;</td><td class="mdescRight">The colour encoding type. <br /></td></tr>
<tr class="separator:a4876401366f11a4c02e6b5e1e3669219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc360af8e47f2fab08335ef0319c29f" id="r_afbc360af8e47f2fab08335ef0319c29f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#afbc360af8e47f2fab08335ef0319c29f">packed</a></td></tr>
<tr class="memdesc:afbc360af8e47f2fab08335ef0319c29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if multiple pixels are packed in the same bytes.  <br /></td></tr>
<tr class="separator:afbc360af8e47f2fab08335ef0319c29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4b8bf93f17ceff24afc5e75613232c" id="r_acd4b8bf93f17ceff24afc5e75613232c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#acd4b8bf93f17ceff24afc5e75613232c">pixelsPerGroup</a></td></tr>
<tr class="memdesc:acd4b8bf93f17ceff24afc5e75613232c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of pixels in a pixel group.  <br /></td></tr>
<tr class="separator:acd4b8bf93f17ceff24afc5e75613232c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af570970ef29915513115cc68dba75a2a" id="r_af570970ef29915513115cc68dba75a2a"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structlibcamera_1_1PixelFormatInfo_1_1Plane.html">Plane</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#af570970ef29915513115cc68dba75a2a">planes</a></td></tr>
<tr class="memdesc:af570970ef29915513115cc68dba75a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about pixels for each plane.  <br /></td></tr>
<tr class="separator:af570970ef29915513115cc68dba75a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Information about pixel formats. </p>
<p>The <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> class groups together information describing a pixel format. It facilitates handling of pixel formats by providing data commonly used in pipeline handlers. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a021bf0e82baec37b1523baa3322dc23c" name="a021bf0e82baec37b1523baa3322dc23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021bf0e82baec37b1523baa3322dc23c">&#9670;&#160;</a></span>ColourEncoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a021bf0e82baec37b1523baa3322dc23c">libcamera::PixelFormatInfo::ColourEncoding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The colour encoding type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a021bf0e82baec37b1523baa3322dc23ca325a4a7e84e64027e36ce0c680f8d018" name="a021bf0e82baec37b1523baa3322dc23ca325a4a7e84e64027e36ce0c680f8d018"></a>ColourEncodingRGB&#160;</td><td class="fielddoc"><p>RGB colour encoding. </p>
</td></tr>
<tr><td class="fieldname"><a id="a021bf0e82baec37b1523baa3322dc23caa7f76b3873550b4beeacfd5d8491d910" name="a021bf0e82baec37b1523baa3322dc23caa7f76b3873550b4beeacfd5d8491d910"></a>ColourEncodingYUV&#160;</td><td class="fielddoc"><p>YUV colour encoding. </p>
</td></tr>
<tr><td class="fieldname"><a id="a021bf0e82baec37b1523baa3322dc23cac31c601b597d4cd2f1ff016875d8e564" name="a021bf0e82baec37b1523baa3322dc23cac31c601b597d4cd2f1ff016875d8e564"></a>ColourEncodingRAW&#160;</td><td class="fielddoc"><p>RAW colour encoding. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a06399e845afd406ce55cc6f1428c0742" name="a06399e845afd406ce55cc6f1428c0742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06399e845afd406ce55cc6f1428c0742">&#9670;&#160;</a></span>frameSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::frameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; unsigned int, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bytes necessary to store a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the frame, in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strides</td><td>The strides to use for each plane</td></tr>
  </table>
  </dd>
</dl>
<p>This function is an overloaded version that takes custom strides for each plane, to be used when the device has custom alignment constraints that can't be described by just an alignment value.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes necessary to store the frame, or 0 if the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> instance is not valid </dd></dl>

</div>
</div>
<a id="aa98fc36a8238e5fbb426089dddef273d" name="aa98fc36a8238e5fbb426089dddef273d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98fc36a8238e5fbb426089dddef273d">&#9670;&#160;</a></span>frameSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::frameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bytes necessary to store a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the frame, in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The stride alignment, in bytes (1 for default alignment)</td></tr>
  </table>
  </dd>
</dl>
<p>The frame size is computed by adding the size of all planes, as computed by <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#ac7e125f99540866dac124ca50303f4f0" title="Compute the number of bytes necessary to store a plane of a frame.">planeSize()</a>, using the specified alignment constraints for all planes. For more complex stride constraints, use the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html#aa98fc36a8238e5fbb426089dddef273d" title="Compute the number of bytes necessary to store a frame.">frameSize()</a> overloaded version that takes an array of stride values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#ac7e125f99540866dac124ca50303f4f0" title="Compute the number of bytes necessary to store a plane of a frame.">planeSize()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes necessary to store the frame, or 0 if the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> instance is not valid </dd></dl>

</div>
</div>
<a id="ab6778b5e339f41911b5fd08c3cb66531" name="ab6778b5e339f41911b5fd08c3cb66531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6778b5e339f41911b5fd08c3cb66531">&#9670;&#160;</a></span>info() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp; libcamera::PixelFormatInfo::info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1PixelFormat.html">PixelFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve information about a pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The pixel format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> describing the <em>format</em> if known, or an invalid <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> otherwise </dd></dl>

</div>
</div>
<a id="a691e354c2bc55a433ed04d211c5f2b27" name="a691e354c2bc55a433ed04d211c5f2b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691e354c2bc55a433ed04d211c5f2b27">&#9670;&#160;</a></span>info() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp; libcamera::PixelFormatInfo::info </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve information about a pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of pixel format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> describing the <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a> matching the <em>name</em> if known, or an invalid <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> otherwise </dd></dl>

</div>
</div>
<a id="ab5ce68ff4d70d12d94769735f8dd304f" name="ab5ce68ff4d70d12d94769735f8dd304f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ce68ff4d70d12d94769735f8dd304f">&#9670;&#160;</a></span>info() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibcamera_1_1PixelFormatInfo.html">PixelFormatInfo</a> &amp; libcamera::PixelFormatInfo::info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1V4L2PixelFormat.html">V4L2PixelFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve information about a V4L2 pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The V4L2 pixel format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> describing the V4L2 <em>format</em> if known, or an invalid <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> otherwise </dd></dl>

</div>
</div>
<a id="acb11cb37fde348f29e723531b30344ac" name="acb11cb37fde348f29e723531b30344ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb11cb37fde348f29e723531b30344ac">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::PixelFormatInfo::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the pixel format info is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the pixel format info is valid, false otherwise </dd></dl>

</div>
</div>
<a id="a41cca8a1c4b7bfd7ed8564812f6cdc49" name="a41cca8a1c4b7bfd7ed8564812f6cdc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cca8a1c4b7bfd7ed8564812f6cdc49">&#9670;&#160;</a></span>numPlanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::numPlanes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of planes represented by the format. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of planes used by the format </dd></dl>

</div>
</div>
<a id="ac7e125f99540866dac124ca50303f4f0" name="ac7e125f99540866dac124ca50303f4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e125f99540866dac124ca50303f4f0">&#9670;&#160;</a></span>planeSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::planeSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bytes necessary to store a plane of a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the frame, in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane</td><td>The plane index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The stride alignment, in bytes (1 for default alignment)</td></tr>
  </table>
  </dd>
</dl>
<p>The plane size is computed by multiplying the line stride and the frame height, taking subsampling and other format characteristics into account. Stride alignment constraints may be specified through the <em>align</em> parameter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PixelFormatInfo.html#a37a284dd919fd4aba5b18138d6eea02a" title="Compute the stride.">stride()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes necessary to store the plane, or 0 if the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> instance is not valid or the plane number isn't valid for the format </dd></dl>

</div>
</div>
<a id="acce305a0a0536f2b2dfdaa99375fa7d1" name="acce305a0a0536f2b2dfdaa99375fa7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce305a0a0536f2b2dfdaa99375fa7d1">&#9670;&#160;</a></span>planeSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::planeSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bytes necessary to store a plane of a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the frame, in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane</td><td>The plane index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>The plane stride, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The plane size is computed by multiplying the line stride and the frame height, taking subsampling and other format characteristics into account. Stride alignment constraints may be specified through the <em>align</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes necessary to store the plane, or 0 if the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> instance is not valid or the plane number isn't valid for the format </dd></dl>

</div>
</div>
<a id="a37a284dd919fd4aba5b18138d6eea02a" name="a37a284dd919fd4aba5b18138d6eea02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a284dd919fd4aba5b18138d6eea02a">&#9670;&#160;</a></span>stride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libcamera::PixelFormatInfo::stride </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the stride. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the line, in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane</td><td>The index of the plane whose stride is to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The stride alignment, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The stride is the number of bytes necessary to store a full line of a frame, including padding at the end of the line. This function takes into account the alignment constraints intrinsic to the format (for instance, the SGRBG12_CSI2P format stores two 12-bit pixels in 3 bytes, and thus has a required stride alignment of 3 bytes). Additional alignment constraints may be specified through the <em>align</em> parameter, which will cause the stride to be rounded up to the next multiple of <em>align</em>.</p>
<p>For multi-planar formats, different planes may have different stride values. The <em>plane</em> parameter selects which plane to compute the stride for.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes necessary to store a line, or 0 if the <a class="el" href="classlibcamera_1_1PixelFormatInfo.html" title="Information about pixel formats.">PixelFormatInfo</a> instance or the <em>plane</em> is not valid </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af66facd7e91d5db482c0e7e49e8d81bd" name="af66facd7e91d5db482c0e7e49e8d81bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66facd7e91d5db482c0e7e49e8d81bd">&#9670;&#160;</a></span>bitsPerPixel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PixelFormatInfo::bitsPerPixel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The average number of bits per pixel. </p>
<p>The number of bits per pixel averages the total number of bits for all colour components over the whole image, excluding any padding bits or padding pixels.</p>
<p>For formats that store pixels with bit padding within words, only the effective bits are taken into account. For instance, 12-bit Bayer data stored in two bytes per pixel report 12, not 16, in this field.</p>
<p>Formats that don't have a fixed number of bits per pixel, such as compressed formats, report 0 in this field. </p>

</div>
</div>
<a id="afbc360af8e47f2fab08335ef0319c29f" name="afbc360af8e47f2fab08335ef0319c29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc360af8e47f2fab08335ef0319c29f">&#9670;&#160;</a></span>packed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PixelFormatInfo::packed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell if multiple pixels are packed in the same bytes. </p>
<p>Packed formats are defined as storing data from multiple pixels in the same bytes. For instance, 12-bit Bayer data with two pixels stored in three bytes is packed, while the same data stored with 4 bits of padding in two bytes per pixel is not packed. </p>

</div>
</div>
<a id="acd4b8bf93f17ceff24afc5e75613232c" name="acd4b8bf93f17ceff24afc5e75613232c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4b8bf93f17ceff24afc5e75613232c">&#9670;&#160;</a></span>pixelsPerGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PixelFormatInfo::pixelsPerGroup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of pixels in a pixel group. </p>
<p>A pixel group is defined as the minimum number of pixels (including padding) necessary in a row when the image has only one column of effective pixels. pixelsPerGroup refers to this value. <a class="el" href="structlibcamera_1_1PixelFormatInfo_1_1Plane.html#aebb35354b0a1c6ee99a0bdf2b9335f31" title="The number of bytes that a pixel group consumes.">PixelFormatInfo::Plane::bytesPerGroup</a>, then, refers to the number of bytes that a pixel group consumes. This definition of a pixel group allows simple calculation of stride, as ceil(width / pixelsPerGroup) * bytesPerGroup. These values are determined only in terms of a row. The ceiling accounts for padding.</p>
<p>A pixel group has a second constraint, such that the pixel group (bytesPerGroup and pixelsPerGroup) is the smallest repeatable unit. What this means is that, for example, in the IPU3 formats, if there is only one column of effective pixels, it looks like it could be fit in 5 bytes with 3 padding pixels (for a total of 4 pixels over 5 bytes). However, this unit is not repeatable, as at the 7th group in the same row, the pattern is broken. Therefore, the pixel group for IPU3 formats must be 25 pixels over 32 bytes.</p>
<p>For example, for something simple like BGR888, it is self-explanatory: the pixel group size is 1, and the bytes necessary is 3, and there is only one plane with no (= 1) vertical subsampling. For YUYV, the CbCr pair is shared between two pixels, so even if you have only one pixel, you would still need a padded second Y sample, therefore the pixel group size is 2, and bytes necessary is 4. YUYV also has no vertical subsampling. NV12 has a pixel group size of 2 pixels, due to the CbCr plane. The bytes per group then, for both planes, is 2. The first plane has no vertical subsampling, but the second plane is subsampled by a factor of 2.</p>
<p>The IPU3 raw Bayer formats are single-planar, and have a pixel group size of 25, consuming 32 bytes, due to the packing pattern being repeated in memory every 32 bytes. The IPU3 hardware, however, has an additional constraint on the DMA burst size, requiring lines to be multiple of 64 bytes. This isn't an intrinsic property of the formats and is thus not reflected here. It is instead enforced by the corresponding pipeline handler. </p>

</div>
</div>
<a id="af570970ef29915513115cc68dba75a2a" name="af570970ef29915513115cc68dba75a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af570970ef29915513115cc68dba75a2a">&#9670;&#160;</a></span>planes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PixelFormatInfo::planes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about pixels for each plane. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlibcamera_1_1PixelFormatInfo_1_1Plane.html" title="Information about a single plane of a pixel format.">PixelFormatInfo::Plane</a> </dd></dl>

</div>
</div>
<a id="a417e6efba30a28758cb7553125b81580" name="a417e6efba30a28758cb7553125b81580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e6efba30a28758cb7553125b81580">&#9670;&#160;</a></span>v4l2Formats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PixelFormatInfo::v4l2Formats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The V4L2 pixel formats corresponding to the <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a>. </p>
<p>Multiple V4L2 formats may exist for one <a class="el" href="classlibcamera_1_1PixelFormat.html" title="libcamera image pixel format">PixelFormat</a>, as V4L2 defines separate 4CCs for contiguous and non-contiguous versions of the same image format. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/peripherals/camera/libcamera/include/libcamera/internal/<a class="el" href="formats_8h_source.html">formats.h</a></li>
<li>src/peripherals/camera/libcamera/src/libcamera/<b>formats.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
