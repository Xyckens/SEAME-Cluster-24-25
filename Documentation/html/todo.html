<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JetPackJoyRide: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JetPackJoyRide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>File <a class="el" href="ipa__interface_8h.html">ipa_interface.h</a>  </dt>
<dd><a class="anchor" id="_todo000032"></a>Add reference to how pipelines shall document their protocol. </dd>
<dt>Class <a class="el" href="classlibcamera_1_1Camera.html">libcamera::Camera</a>  </dt>
<dd><a class="anchor" id="_todo000019"></a>Add documentation for camera start timings. What exactly does the camera expect the pipeline handler to do when <a class="el" href="classlibcamera_1_1Camera.html#a5c033a72ac66fbdd2c2bb9f934389dcf" title="Start capture from camera.">start()</a> is called? </dd>
<dt>Member <a class="el" href="classlibcamera_1_1Camera_1_1Private.html#ab4e183eb4dabe929d1b2bbbb519b969f">libcamera::Camera::Private::controlInfo_</a>  </dt>
<dd><a class="anchor" id="_todo000018"></a>This member was initially meant to stay constant after the camera is created. Several pipeline handlers are already updating it when the camera is configured. Update the documentation accordingly, and possibly the API as well, when implementing official support for control info updates.  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1CameraConfiguration.html#a29f8f263384c6149775b6011c7397093">libcamera::CameraConfiguration::validate</a>  ()=0</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000016"></a>Define exactly when to return each status code. Should stream parameters set to 0 by the caller be adjusted without returning Adjusted ? This would potentially be useful for applications but would get in the way in <a class="el" href="classlibcamera_1_1Camera.html#a4c190f4c369628e5cd96770790559a26" title="Configure the camera prior to capture.">Camera::configure()</a>. Do we need an extra status code to signal this ?</p>
<p class="enddd"><a class="anchor" id="_todo000017"></a>Handle validation of buffers count when refactoring the buffers API. </p>
</dd>
<dt>Member <a class="el" href="classlibcamera_1_1CameraSensor.html#a36b9ce9307b2b6eb1c741d59b6473368">libcamera::CameraSensor::applyConfiguration</a>  (const <a class="el" href="classlibcamera_1_1SensorConfiguration.html" title="Camera sensor configuration.">SensorConfiguration</a> &amp;config, Transform transform=<a class="el" href="namespacelibcamera.html#a371b6d17d531b85c035c4e889b116571ac9c5c65fb4af9cf90eb99b3b84424189">Transform::Identity</a>, <a class="el" href="structlibcamera_1_1V4L2SubdeviceFormat.html" title="The V4L2 sub-device image format and sizes.">V4L2SubdeviceFormat</a> *sensorFormat=nullptr)=0</dt>
<dd><a class="anchor" id="_todo000046"></a>The configuration shall be fully populated and if any of the fields specified cannot be applied exactly, an error code is returned. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1CameraSensor.html#ab14ea54646bd5c542a5950de5c7671f0">libcamera::CameraSensor::device</a>  ()=0</dt>
<dd><a class="anchor" id="_todo000043"></a>Remove this function by integrating DelayedControl with <a class="el" href="classlibcamera_1_1CameraSensor.html" title="A abstract camera sensor.">CameraSensor</a>  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1CameraSensor.html#abcd1c5043bbf5c848a4187a3e36fad13">libcamera::CameraSensor::resolution</a>  () const =0</dt>
<dd><a class="anchor" id="_todo000044"></a>Consider if it desirable to distinguish between the maximum resolution the sensor can produce (also including upscaled ones) and the actual pixel array size by splitting this function in two. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1CameraSensor.html#a1d3d7d3ef571499184fbe7425f8da927">libcamera::CameraSensor::tryFormat</a>  (<a class="el" href="structlibcamera_1_1V4L2SubdeviceFormat.html" title="The V4L2 sub-device image format and sizes.">V4L2SubdeviceFormat</a> *format) const =0</dt>
<dd><a class="anchor" id="_todo000045"></a>Add support for Transform by changing the format's Bayer ordering before calling subdev_-&gt;<a class="el" href="classlibcamera_1_1CameraSensor.html#ad871514dff7a30406df5f8cd557672d7" title="Set the sensor output format.">setFormat()</a>. </dd>
<dt>Class <a class="el" href="classlibcamera_1_1ColorSpace.html">libcamera::ColorSpace</a>  </dt>
<dd><a class="anchor" id="_todo000021"></a>Define the color space fully in the libcamera API to avoid referencing V4L2  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ControlList.html#a0d02e5d02a5b278bb4eebb9c2dfeac2a">libcamera::ControlList::merge</a>  (const <a class="el" href="classlibcamera_1_1ControlList.html" title="Associate a list of ControlId with their values for an object.">ControlList</a> &amp;source, MergePolicy policy=<a class="el" href="classlibcamera_1_1ControlList.html#a61c8b9a57df34e40716d3664d24df80da52a9854287113e3ba9a005ff73c54c7b" title="Existing controls in the target list are kept.">MergePolicy::KeepExisting</a>)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000024"></a>Reimplement or implement an overloaded version which internally uses std::unordered_map::merge() and accepts a non-const argument. </p>
<p class="enddd"><a class="anchor" id="_todo000025"></a>ASSERT that the current and source <a class="el" href="classlibcamera_1_1ControlList.html" title="Associate a list of ControlId with their values for an object.">ControlList</a> are derived from a compatible ControlIdMap, to prevent undefined behaviour due to id collisions. </p>
</dd>
<dt>Member <a class="el" href="classlibcamera_1_1ControlSerializer.html#aad8c06e31fce42fbd9b0dd7464ad9078">libcamera::ControlSerializer::deserialize</a>  (<a class="el" href="classlibcamera_1_1ByteStreamBuffer.html" title="Wrap a memory buffer and provide sequential data read and write.">ByteStreamBuffer</a> &amp;buffer)</dt>
<dd><a class="anchor" id="_todo000022"></a>Find a way to preserve the control name for debugging purpose.  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ControlValue.html#a8121fc11c868a2c6d153982a776914b0">libcamera::ControlValue::ControlValue</a>  ()</dt>
<dd><a class="anchor" id="_todo000023"></a>Revisit the <a class="el" href="classlibcamera_1_1ControlValue.html" title="Abstract type representing the value of a control.">ControlValue</a> layout when stabilizing the ABI  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1DmaBufAllocator.html#a5e1a0a9ab8d3494e4a73fbabe5cbb07e">libcamera::DmaBufAllocator::exportBuffers</a>  (unsigned int count, const std::vector&lt; unsigned int &gt; &amp;planeSizes, std::vector&lt; std::unique_ptr&lt; FrameBuffer &gt; &gt; *buffers)</dt>
<dd><a class="anchor" id="_todo000026"></a>Add the option to allocate each plane with a dma buf respectively. </dd>
<dt>Struct <a class="el" href="structlibcamera_1_1FrameBuffer_1_1Plane.html">libcamera::FrameBuffer::Plane</a>  </dt>
<dd><a class="anchor" id="_todo000028"></a>Specify how an application shall decide whether to use a single or multiple dmabufs, based on the camera requirements.  </dd>
<dt>Member <a class="el" href="structlibcamera_1_1FrameMetadata.html#a08999a7c7b62eeba0a36d352c314bc65">libcamera::FrameMetadata::timestamp</a>  </dt>
<dd><a class="anchor" id="_todo000027"></a>Be more precise on what timestamps refer to.  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ImgUDevice.html#abab917b2cd40b6c04d008706b41d60c8">libcamera::ImgUDevice::enableLinks</a>  (bool enable)</dt>
<dd><a class="anchor" id="_todo000038"></a>This function will probably be removed or changed once links will be enabled or disabled selectively. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ipa_1_1CameraSensorHelper.html#ad6d462fc5828e841563289eef22d3174">libcamera::ipa::CameraSensorHelper::blackLevel</a>  () const</dt>
<dd><a class="anchor" id="_todo000007"></a>Fill the blanks and add pedestal values for all supported sensors. Once done, drop the std::optional&lt;&gt;. </dd>
<dt>Class <a class="el" href="classlibcamera_1_1ipa_1_1FCQueue.html">libcamera::ipa::FCQueue&lt; FrameContext &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000008"></a>Mark the frame context with a per-frame control error flag in case of underrun, and research how algorithms should handle this. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ipa_1_1FCQueue.html#a7a76eebb86d4d5b41fff9d4e950fb385">libcamera::ipa::FCQueue&lt; FrameContext &gt;::clear</a>  ()</dt>
<dd><a class="anchor" id="_todo000009"></a>Fix any issue this may cause with requests queued before the camera is started.  </dd>
<dt>Struct <a class="el" href="structlibcamera_1_1ipa_1_1ipu3_1_1algorithms_1_1Accumulator.html">libcamera::ipa::ipu3::algorithms::Accumulator</a>  </dt>
<dd><a class="anchor" id="_todo000003"></a>move this description and structure into a common header </dd>
<dt>Member <a class="el" href="classlibcamera_1_1ipa_1_1ipu3_1_1IPAIPU3.html#a9206f03f723d4eaedc61de71d44b311b">libcamera::ipa::ipu3::IPAIPU3::configure</a>  (const IPAConfigInfo &amp;configInfo, <a class="el" href="classlibcamera_1_1ControlInfoMap.html" title="A map of ControlId to ControlInfo.">ControlInfoMap</a> *ipaControls) override</dt>
<dd><a class="anchor" id="_todo000005"></a>Document what the BDS is, ideally in a block diagram of the ImgU. </dd>
<dt>Class <a class="el" href="classlibcamera_1_1ipa_1_1rkisp1_1_1algorithms_1_1Filter.html">libcamera::ipa::rkisp1::algorithms::Filter</a>  </dt>
<dd><a class="anchor" id="_todo000010"></a>In current version the denoise and sharpness control is based on user controls. In a future version it should be controlled automatically by the algorithm.  </dd>
<dt>Class <a class="el" href="classlibcamera_1_1IPADataSerializer.html">libcamera::IPADataSerializer&lt; T &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000030"></a>Harden the vector and map deserializer</p>
<p class="interdd"><a class="anchor" id="_todo000031"></a>For SharedFDs, instead of storing a validity flag, store an index into the fd array. This will allow us to use views instead of copying. </p>
<p class="enddd"><a class="anchor" id="_todo000029"></a>Switch to <a class="el" href="classlibcamera_1_1Span.html">Span</a> instead of byte and fd vector </p>
</dd>
<dt>Class <a class="el" href="classlibcamera_1_1IPAInterface.html">libcamera::IPAInterface</a>  </dt>
<dd><a class="anchor" id="_todo000033"></a>Figure out how to generate <a class="el" href="classlibcamera_1_1IPAInterface.html" title="C++ Interface for IPA implementation.">IPAInterface</a> documentation.  </dd>
<dt>Member <a class="el" href="structlibcamera_1_1IPAModuleInfo.html#ac8fb4c26b65a2fbad350fc185445164d">libcamera::IPAModuleInfo::name</a>  [256]</dt>
<dd><a class="anchor" id="_todo000034"></a>Allow user to choose to isolate open source IPAs  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1IPCMessage.html#a18d9502a924db483ee1deffe37de8117">libcamera::IPCMessage::payload</a>  () const</dt>
<dd><a class="anchor" id="_todo000035"></a>Resolve the layering violation (add other converters later?)  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1IPCPipe.html#a4071e1ef36dfb902b766b5f28330457b">libcamera::IPCPipe::sendSync</a>  (const <a class="el" href="classlibcamera_1_1IPCMessage.html" title="IPC message to be passed through IPC message pipe.">IPCMessage</a> &amp;in, <a class="el" href="classlibcamera_1_1IPCMessage.html" title="IPC message to be passed through IPC message pipe.">IPCMessage</a> *out)=0</dt>
<dd><a class="anchor" id="_todo000036"></a>Determine if the event loop should limit the types of messages it processes, to avoid reintrancy in the caller, and carefully document what the caller needs to implement to make this safe.  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1IPCUnixSocket.html#a11995aca6423a568e6d1303dc80cd239">libcamera::IPCUnixSocket::receive</a>  (<a class="el" href="structlibcamera_1_1IPCUnixSocket_1_1Payload.html" title="Container for an IPC payload.">Payload</a> *payload)</dt>
<dd><a class="anchor" id="_todo000037"></a>Add state machine to make sure we don't block forever and that a header is always followed by a payload. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1Object.html#a6e81f2a2524dbe12daed49597cf66a57">libcamera::Object::assertThreadBound</a>  (const char *message)</dt>
<dd><a class="anchor" id="_todo000012"></a>Verify the thread-bound requirements for functions marked as thread-bound at the class level. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1Request.html#ac620539cc50a28bd9ff9f8f697eb86c3">libcamera::Request::metadata</a>  ()</dt>
<dd><a class="anchor" id="_todo000042"></a>Offer a read-only API towards applications while keeping a read/write API internally.  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1Request.html#adce12d1213e5d894a5697ddd4b94b672">libcamera::Request::Request</a>  (<a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> *camera, uint64_t cookie=0)</dt>
<dd><a class="anchor" id="_todo000041"></a>Add a validator for metadata controls.  </dd>
<dt>Class <a class="el" href="classlibcamera_1_1SensorConfiguration.html">libcamera::SensorConfiguration</a>  </dt>
<dd><a class="anchor" id="_todo000014"></a>Applications shall fully populate all fields of the <a class="el" href="classlibcamera_1_1CameraConfiguration.html#a2976d0bb17d7bb416e2bfc984d096c7d" title="The camera sensor configuration.">CameraConfiguration::sensorConfig</a> class members before validating the <a class="el" href="classlibcamera_1_1CameraConfiguration.html" title="Hold configuration for streams of the camera.">CameraConfiguration</a>. If the <a class="el" href="classlibcamera_1_1SensorConfiguration.html" title="Camera sensor configuration.">SensorConfiguration</a> is not fully populated, or if any of its parameters cannot be applied to the sensor in use, the <a class="el" href="classlibcamera_1_1CameraConfiguration.html" title="Hold configuration for streams of the camera.">CameraConfiguration</a> validation process will fail and return <a class="el" href="classlibcamera_1_1CameraConfiguration.html#a64163f21db2fe1ce0a6af5a6f6847744abb3f4b9430dffdc7a148758fe6d70d57">CameraConfiguration::Status::Invalid</a>. </dd>
<dt>Member <a class="el" href="classlibcamera_1_1SensorConfiguration.html#a6f276fafe03f0564f61da6ed4f174124">libcamera::SensorConfiguration::isValid</a>  () const</dt>
<dd><a class="anchor" id="_todo000015"></a>For now allow applications to populate the bitDepth and the outputSize only as skipping and binnings factors are initialized to 1 and the analog crop is ignored. </dd>
<dt>Class <a class="el" href="classlibcamera_1_1Stream.html">libcamera::Stream</a>  </dt>
<dd><a class="anchor" id="_todo000049"></a>Add capabilities to the stream API. Without this the <a class="el" href="classlibcamera_1_1Stream.html" title="Video stream for a camera.">Stream</a> class only serves to reveal how many streams of unknown capabilities a camera supports. This in itself is productive as it allows applications to configure and capture from one or more streams even if they won't be able to select the optimal stream for the task.  </dd>
<dt>Member <a class="el" href="structlibcamera_1_1StreamConfiguration.html#a396e09188db732ef3f8a149808d876f7">libcamera::StreamConfiguration::StreamConfiguration</a>  ()</dt>
<dd><a class="anchor" id="_todo000048"></a>This function is deprecated and should be removed once all pipeline handlers provide <a class="el" href="classlibcamera_1_1StreamFormats.html" title="Hold information about supported stream formats.">StreamFormats</a>.  </dd>
<dt>Class <a class="el" href="classlibcamera_1_1StreamFormats.html">libcamera::StreamFormats</a>  </dt>
<dd><a class="anchor" id="_todo000047"></a>Review the usage patterns of this class, and cache the computed <a class="el" href="classlibcamera_1_1StreamFormats.html#ab956a73dcc86314d903227ad736a29a4" title="Retrieve the list of supported pixel formats.">pixelformats()</a>, <a class="el" href="classlibcamera_1_1StreamFormats.html#a4321746fcfffed9750f6f9dbffcf102b" title="Retrieve the list of frame sizes supported for pixelformat.">sizes()</a> and <a class="el" href="classlibcamera_1_1StreamFormats.html#a8f966e5f785f2c30669889c5b5307801" title="Retrieve the range of minimum and maximum sizes.">range()</a> if this would improve performances.  </dd>
<dt>Member <a class="el" href="include_2libcamera_2base_2utils_8h.html#a24701cae6640674865484b40b2325a7d">libcamera::utils::split</a>  (const std::string &amp;str, const std::string &amp;delim)</dt>
<dd><a class="anchor" id="_todo000013"></a>Try to avoid copies of str and delim  </dd>
<dt>Member <a class="el" href="classlibcamera_1_1V4L2Subdevice.html#a73ac07ba76587bb56181aa699cd15554">libcamera::V4L2Subdevice::getSelection</a>  (const <a class="el" href="structlibcamera_1_1V4L2Subdevice_1_1Stream.html" title="V4L2 subdevice stream.">Stream</a> &amp;stream, unsigned int target, <a class="el" href="classlibcamera_1_1Rectangle.html" title="Describe a rectangle&#39;s position and dimensions.">Rectangle</a> *rect)</dt>
<dd><a class="anchor" id="_todo000050"></a>Define a V4L2SelectionTarget enum for the selection target </dd>
<dt>Member <a class="el" href="classlibcamera_1_1V4L2Subdevice.html#a62c91acb30f22a4b526b157c03d2cc60">libcamera::V4L2Subdevice::setSelection</a>  (const <a class="el" href="structlibcamera_1_1V4L2Subdevice_1_1Stream.html" title="V4L2 subdevice stream.">Stream</a> &amp;stream, unsigned int target, <a class="el" href="classlibcamera_1_1Rectangle.html" title="Describe a rectangle&#39;s position and dimensions.">Rectangle</a> *rect)</dt>
<dd><a class="anchor" id="_todo000051"></a>Define a V4L2SelectionTarget enum for the selection target </dd>
<dt>Member <a class="el" href="classlibcamera_1_1V4L2Subdevice.html#a8e021fbbd868e89103c0619afce3470b">libcamera::V4L2Subdevice::setSelection</a>  (unsigned int pad, unsigned int target, <a class="el" href="classlibcamera_1_1Rectangle.html" title="Describe a rectangle&#39;s position and dimensions.">Rectangle</a> *rect)</dt>
<dd><a class="anchor" id="_todo000052"></a>Define a V4L2SelectionTarget enum for the selection target </dd>
<dt>Member <a class="el" href="classlibcamera_1_1V4L2VideoDevice.html#a930659ca05a6475a2b2d1ad2961ee318">libcamera::V4L2VideoDevice::getSelection</a>  (unsigned int target, <a class="el" href="classlibcamera_1_1Rectangle.html" title="Describe a rectangle&#39;s position and dimensions.">Rectangle</a> *rect)</dt>
<dd><a class="anchor" id="_todo000053"></a>Define a V4L2SelectionTarget enum for the selection target </dd>
<dt>Member <a class="el" href="classlibcamera_1_1V4L2VideoDevice.html#aa9eba638ac570ac4746017c6f10fafaa">libcamera::V4L2VideoDevice::setSelection</a>  (unsigned int target, <a class="el" href="classlibcamera_1_1Rectangle.html" title="Describe a rectangle&#39;s position and dimensions.">Rectangle</a> *rect)</dt>
<dd><a class="anchor" id="_todo000054"></a>Define a V4L2SelectionTarget enum for the selection target </dd>
<dt>Member <a class="el" href="libcamera_2base_2log_8h.html#a3577749fb48d57a158b8ac1a0b3ab57e">LOG</a>  (...)</dt>
<dd><a class="anchor" id="_todo000011"></a>Allow logging from destructors of global objects to the largest possible extent </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
